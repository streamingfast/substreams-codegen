import { log } from "@graphprotocol/graph-ts";
import { Protobuf } from "as-proto/assembly";
import { JSON } from "assemblyscript-json";
{{- if and .TrackAnyEvents .TrackAnyCalls }}
import { Call, Event } from "../generated/schema";
import { Events } from "./pb/contract/v1/Events";
import { Calls } from "./pb/contract/v1/Calls";
import { EventsCalls } from "./pb/contract/v1/EventsCalls";
{{- else if .TrackAnyEvents }}
import { Event } from "../generated/schema";
import { Events } from "./pb/contract/v1/Events";
{{- else if .TrackAnyCalls }}
import { Call } from "../generated/schema";
import { Calls } from "./pb/contract/v1/Calls";
{{- end }}

{{ if and .TrackAnyEvents .TrackAnyCalls }}
export function handleEventsAndCalls(bytes: Uint8Array): void {
  const eventsCalls: EventsCalls = Protobuf.decode<EventsCalls>(
    bytes,
    EventsCalls.decode
  );
  const events: Events | null = eventsCalls.events;
  if (events === null) {
    return;
  }
  const calls: Calls | null = eventsCalls.calls;
  if (calls === null) {
    return;
  }
{{ else if .TrackAnyEvents }}
export function handleEvents(bytes: Uint8Array): void {
  const events: Events = Protobuf.decode<Events>(bytes, Events.decode);
{{ else if .TrackAnyCalls }}
export function handleCalls(bytes: Uint8Array): void {
  const calls: Calls = Protobuf.decode<Calls>(bytes, Calls.decode);
{{- end }}  

{{- if .TrackAnyEvents }}
  // Below you will find examples of how to save the decoded events.
  // These are only examples, you can modify them to suit your needs.
  {{- range $i, $contract := .AllContracts }}
  {{- range $event := $contract.EventModels }}
  {{- $rust := $event.Rust }}
  for (let i = 0; i < events.{{ $contract.IdentityCamelCase }}{{ $rust.ProtoOutputModuleFieldSubgraphTriggerName }}.length; i++) {
    const e = events.{{ $contract.IdentityCamelCase }}{{ $rust.ProtoOutputModuleFieldSubgraphTriggerName }}[i];
    let evt = new Event(ID(e.evtTxHash, i));
    let obj = new JSON.Obj();
    obj.set("evtTxHash", e.evtTxHash);
    obj.set("evtIndex", e.evtIndex);
    obj.set("evtBlockTime", e.evtBlockTime);
    obj.set("evtBlockNumber", e.evtBlockNumber);
    {{- range $subgraphField, $subgraphFieldMapping := $rust.ProtoFieldSubgraphMappings }}
    obj.set("{{ $subgraphField }}", {{ $subgraphFieldMapping }});
    {{- end}}
    evt.jsonValue = obj.toString();
    evt.type = "{{ toLowerCamelCase $rust.ABIStructName }}";
    evt.save();
  }
  {{ end }}{{/* range $event := $contract.EventModels */}}
  {{- end }}{{/* range $i, $contract := .AllContracts  */}}
{{- end }}
{{- if .TrackAnyCalls }}
  // Below you will find examples of how to save the decoded calls.
  // These are only examples, you can modify them to suit your needs.

  {{- range $i, $contract := .AllContracts }}
  {{- range $call := $contract.CallModels }}
  {{- $rust := $call.Rust }}
  for (let i = 0; i < calls.{{ $contract.IdentityCamelCase }}{{ $rust.ProtoOutputModuleFieldSubgraphTriggerName }}.length; i++) {
    const c = calls.{{ $contract.IdentityCamelCase }}{{ $rust.ProtoOutputModuleFieldSubgraphTriggerName }}[i];
    let call = new Call(ID(c.callTxHash, i));
    let obj = new JSON.Obj();
    obj.set("callTxHash", c.callTxHash);
    obj.set("callBlockTime", c.callBlockTime);
    obj.set("callBlockNumber", c.callBlockNumber);
    obj.set("callOrdinal", c.callOrdinal);
    obj.set("callSuccess", c.callSuccess);
    {{- range $subgraphField, $subgraphFieldMapping := $rust.ProtoFieldSubgraphMappings }}
    obj.set("{{ $subgraphField }}", {{ $subgraphFieldMapping }});
    {{- end}}
    call.jsonValue = obj.toString();
    call.type = "{{ toLowerCamelCase $rust.ABIStructName }}";
    call.save();
  }
  {{ end }}{{/* range $call := $contract.CallModels */}}
  {{- end }}{{/* range $i, $contract := .AllContracts */}}
{{- end }}
{{ print "}" }}

function ID(trxHash: string, i: u32): string {
  return trxHash + "-" + i.toString();
}
