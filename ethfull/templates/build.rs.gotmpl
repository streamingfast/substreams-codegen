use anyhow::{Ok, Result};
use regex::Regex;
use substreams_ethereum::Abigen;
use std::fs;

fn main() -> Result<(), anyhow::Error> {
    let file_names = [
        {{- range $i, $contract := .Contracts }}
        "abi/{{ $contract.Identifier }}_contract.abi.json",
        {{- end }}
        {{- range $ddsContract := .DynamicContracts }}
        "abi/{{ $ddsContract.Identifier }}_contract.abi.json",
        {{- end }}
    ];
    let file_output_names = [
        {{- range $i, $contract := .Contracts }}
        "src/abi/{{ $contract.Identifier }}_contract.rs",
        {{- end }}
        {{- range $ddsContract := .DynamicContracts }}
        "src/abi/{{ $ddsContract.Identifier }}_contract.rs",
        {{- end }}
    ];

    let mut i = 0;
    for f in file_names {
        let contents = fs::read_to_string(f)
            .expect("Should have been able to read the file");

        // sanitize fields and attributes starting with an underscore
        let regex = Regex::new(r#"("\w+"\s?:\s?")_(\w+")"#).unwrap();
        let sanitized_abi_file = regex.replace_all(contents.as_str(), "${1}u_${2}");

        // sanitize fields and attributes with multiple consecutive underscores
        let re = Regex::new(r"_+").unwrap();

        let re_sanitized_abi_file = re.replace_all(&sanitized_abi_file, |caps: &regex::Captures| {
            if caps[0].len() > 1 {
                "_u".to_string()
            } else {
                caps[0].to_string()
            }
        });

        Abigen::from_bytes("Contract", re_sanitized_abi_file.as_bytes())?
            .generate()?
            .write_to_file(file_output_names[i])?;

        i = i+1;
    }

    Ok(())
}
